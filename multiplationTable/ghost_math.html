<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ghost Math</title>
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff9d00;
            --text-color: #e0e0e0;
            --ghost-color: #f8f8ff;
            --ghost-shadow: rgba(0, 0, 0, 0.3);
            --selected-glow: 0 0 20px #00ff00, 0 0 40px #00ff00;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #2c001e;
            /* PURPLE THEME to prove it's the new version */
            background-image: linear-gradient(to bottom, #2c001e, #000000);
            font-family: 'Creepster', cursive;
            color: var(--text-color);
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        /* Graveyard Background Elements */
        .background-element {
            position: absolute;
            bottom: 0;
            pointer-events: none;
            opacity: 0.6;
            z-index: 1;
        }

        .moon {
            position: absolute;
            top: 50px;
            right: 50px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 0 40px #fff;
            opacity: 0.8;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 2rem;
            text-shadow: 2px 2px 4px #000;
        }

        #score-display {
            color: var(--primary-color);
        }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 6rem;
            margin: 0;
            color: var(--primary-color);
            text-shadow: 4px 4px 0px #3d0000;
            animation: float 3s ease-in-out infinite;
        }

        button {
            margin-top: 40px;
            padding: 15px 40px;
            font-size: 2.5rem;
            font-family: 'Creepster', cursive;
            background: transparent;
            color: white;
            border: 4px solid var(--primary-color);
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            pointer-events: auto;
            position: relative;
            z-index: 10001;
        }

        button:hover {
            background: var(--primary-color);
            color: #000;
            transform: scale(1.1);
        }

        /* Ghost Styles */
        .ghost {
            position: absolute;
            width: 100px;
            height: 120px;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 120'%3E%3Cpath d='M10,60 Q10,10 50,10 Q90,10 90,60 Q90,90 80,100 Q70,90 60,100 Q50,90 40,100 Q30,90 20,100 Q10,90 10,60' fill='%23f8f8ff' stroke='%23ddd' stroke-width='2' opacity='0.9'/%3E%3Ccircle cx='35' cy='45' r='5' fill='%23333'/%3E%3Ccircle cx='65' cy='45' r='5' fill='%23333'/%3E%3Cpath d='M40,65 Q50,75 60,65' fill='none' stroke='%23333' stroke-width='3' stroke-linecap='round'/%3E%3C/svg%3E") no-repeat center center;
            background-size: contain;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Roboto', sans-serif;
            font-weight: bold;
            font-size: 1.5rem;
            color: #333;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s, filter 0.2s;
            filter: drop-shadow(0 0 10px var(--ghost-shadow));
            padding-top: 20px;
        }

        .ghost.selected {
            filter: drop-shadow(0 0 15px #00ff00);
            transform: scale(1.15);
            z-index: 20;
        }

        /* Particles/Effects */
        .poof {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 70%);
            border-radius: 50%;
            transform: scale(0);
            animation: poofAnim 0.4s ease-out forwards;
            pointer-events: none;
            z-index: 15;
        }

        @keyframes poofAnim {
            0% {
                transform: scale(0.1);
                opacity: 1;
            }

            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        #final-score {
            font-family: 'Roboto', sans-serif;
            font-size: 2rem;
            margin-bottom: 20px;
        }

        #input-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 4rem;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 40px;
            border-radius: 10px;
            border: 4px solid var(--primary-color);
            z-index: 50;
            display: block;
            /* Always show */
            min-width: 100px;
            text-align: center;
        }

        #hidden-input {
            opacity: 0;
            position: absolute;
            z-index: -1;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div class="moon"></div>
        <div class="background-element"
            style="left: 10%; height: 60px; width: 40px; background: #444; border-radius: 20px 20px 0 0;"></div>
        <div class="background-element"
            style="left: 25%; height: 80px; width: 50px; background: #333; border-radius: 25px 25px 0 0;"></div>
        <div class="background-element"
            style="left: 60%; height: 50px; width: 40px; background: #3a3a3a; border-radius: 20px 20px 0 0;"></div>
        <div class="background-element"
            style="left: 85%; height: 70px; width: 55px; background: #2f2f2f; border-radius: 30px 30px 0 0;"></div>

        <div id="ui-layer">
            Score: <span id="score">0</span>
        </div>

        <div id="input-display"></div>

        <div id="game-over-screen" class="overlay hidden">
            <h1 style="color: #ff3333;">Game Over</h1>
            <div id="final-score">Score: 0</div>
            <button id="restart-btn">Try Again</button>
        </div>

        <input type="number" id="hidden-input" pattern="\d*">
    </div>

    <div id="debug-log"
        style="position:fixed; bottom:0; left:0; width:100%; height:100px; background:rgba(0,0,0,0.8); color:#0f0; font-family:monospace; overflow-y:scroll; z-index:99999; padding:10px; box-sizing:border-box;">
        Debug Log Initialized...</div>

    <script>
        // Debug Logger
        const debugEl = document.getElementById('debug-log');
        function log(msg) {
            console.log(msg);
            if (debugEl) {
                const line = document.createElement('div');
                line.textContent = '> ' + msg;
                debugEl.appendChild(line);
                debugEl.scrollTop = debugEl.scrollHeight;
            }
        }

        window.onerror = function (msg, url, line, col, error) {
            log("ERROR: " + msg + " at line " + line);
            return false;
        };

        log("Script loaded. Waiting for interaction...");

        /* Game Configuration */
        const GAME_WIDTH = window.innerWidth;
        const GAME_HEIGHT = window.innerHeight;

        const STATE = {
            isPlaying: false,
            score: 0,
            ghosts: [],
            spawnInterval: 2000,
            spawnTimer: 0,
            lastFrameTime: 0,
            spawnTimer: 0,
            lastFrameTime: 0,
            speedMultiplier: 1,
            loopId: 0
        };

        // Global Input Buffer
        let globalInput = "";
        let inputTimeout;

        /* Elements */
        let container, scoreEl, startScreen, gameOverScreen, finalScoreEl, inputDisplay, hiddenInput;

        try {
            container = document.getElementById('game-container');
            scoreEl = document.getElementById('score');
            startScreen = document.getElementById('start-screen');
            gameOverScreen = document.getElementById('game-over-screen');
            finalScoreEl = document.getElementById('final-score');
            inputDisplay = document.getElementById('input-display');
            hiddenInput = document.getElementById('hidden-input');

            if (!startScreen) log("CRITICAL: Start screen not found in DOM");
            if (!document.getElementById('start-btn')) log("CRITICAL: Start button not found in DOM");

            /* Setup Event Listeners */
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.addEventListener('click', function () {
                    log("Start button clicked");
                    startGame();
                });
            }

            const restartBtn = document.getElementById('restart-btn');
            if (restartBtn) restartBtn.addEventListener('click', startGame);

            // Global key listener
            document.addEventListener('keydown', handleInput);

            // Mobile listener
            if (hiddenInput) {
                hiddenInput.addEventListener('input', (e) => {
                    const val = e.target.value;
                    if (val) {
                        const char = val.slice(-1);
                        processInputChar(char);
                    }
                    e.target.value = '';
                });
            }

            // Keep focus for mobile
            if (container) {
                container.addEventListener('click', () => {
                    try { if (hiddenInput) hiddenInput.focus(); } catch (e) { }
                });
            }

        } catch (e) {
            log("Setup Error: " + e.message);
        }

        /* Game Logic */


        function startGame() {
            try {
                STATE.isPlaying = true;
                STATE.score = 0;
                STATE.loopId++; // Increment loop ID
                const currentLoopId = STATE.loopId;

                if (STATE.ghosts) {
                    STATE.ghosts.forEach(g => { if (g.element) g.element.remove(); });
                }
                STATE.ghosts = [];

                STATE.spawnInterval = 2500;
                STATE.speedMultiplier = 1;
                STATE.lastFrameTime = performance.now();
                STATE.spawnTimer = 0;

                if (scoreEl) scoreEl.innerText = '0';

                if (gameOverScreen) gameOverScreen.classList.add('hidden');

                globalInput = "";
                try { if (hiddenInput) hiddenInput.focus(); } catch (e) { }

                requestAnimationFrame((t) => gameLoop(t, currentLoopId));
            } catch (err) {
                alert("Game Error: " + err.message);
            }
        }

        function gameOver() {
            if (!STATE.isPlaying) return;
            STATE.isPlaying = false;
            // loopId check handles stopping naturally
            if (finalScoreEl) finalScoreEl.innerText = `Final Score: ${STATE.score}`;
            if (gameOverScreen) gameOverScreen.classList.remove('hidden');
        }

        function gameLoop(timestamp, loopId) {
            if (!STATE.isPlaying || loopId !== STATE.loopId) return;
            // Cap deltaTime to 50ms (20fps) to prevent huge jumps if browser lags
            const rawDelta = timestamp - STATE.lastFrameTime;
            const deltaTime = Math.min(rawDelta, 50);
            STATE.lastFrameTime = timestamp;
            update(deltaTime);
            requestAnimationFrame((t) => gameLoop(t, loopId));
        }

        function update(deltaTime) {
            STATE.spawnTimer += deltaTime;
            if (STATE.spawnTimer > STATE.spawnInterval) {
                spawnGhost();
                STATE.spawnTimer = 0;
                STATE.spawnInterval = Math.max(800, STATE.spawnInterval * 0.98);
                STATE.speedMultiplier = Math.min(3, STATE.speedMultiplier + 0.01);
            }

            for (let i = STATE.ghosts.length - 1; i >= 0; i--) {
                const ghost = STATE.ghosts[i];
                ghost.x += ghost.speed * STATE.speedMultiplier * (deltaTime / 16);

                if (ghost.element) {
                    ghost.element.style.left = `${ghost.x}px`;
                    // "Normal" movement: Straight line (removed the bobbing)
                    ghost.element.style.top = `${ghost.y}px`;
                }

                if (ghost.x > window.innerWidth) {
                    // ENDLESS MODE: Wrap around instead of Game Over
                    ghost.x = -100;
                    ghost.y = Math.random() * (window.innerHeight - 200) + 50;
                }
            }
        }

        function timestampToSeconds() { return STATE.lastFrameTime / 1000; }

        class Ghost {
            constructor() {
                this.id = Math.random();
                this.x = -100;
                this.y = Math.random() * (window.innerHeight - 200) + 50;
                // SLOWER SPEED: 0.5 to 1.3 pixels per frame (was 1.0 to 2.5)
                this.speed = Math.random() * 0.8 + 0.5;

                const num1 = Math.floor(Math.random() * 9) + 2;
                const num2 = Math.floor(Math.random() * 9) + 2;
                this.question = `${num1} Ã— ${num2}`;
                this.answer = num1 * num2;

                this.element = document.createElement('div');
                this.element.classList.add('ghost');
                this.element.innerText = this.question;
                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;

                // Allow clicking to select/highlight if desired, but not needed for input now
                this.element.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Visual feedback?
                    try { if (hiddenInput) hiddenInput.focus(); } catch (e) { }
                });

                if (container) container.appendChild(this.element);
            }
        }

        function spawnGhost() {
            const ghost = new Ghost();
            STATE.ghosts.push(ghost);
        }

        function handleInput(e) {
            if (!STATE.isPlaying) return;
            if (e.key >= '0' && e.key <= '9') {
                processInputChar(e.key);
            } else if (e.key === 'Backspace') {
                globalInput = globalInput.slice(0, -1);
                updateVisualInput();
            }
        }

        function processInputChar(char) {
            clearTimeout(inputTimeout);
            inputTimeout = setTimeout(() => {
                globalInput = "";
                updateVisualInput();
            }, 3000); // 3s timeout

            const nextInput = globalInput + char;

            // STRICT MODE: Check if this new string could possibly be an answer
            const isPrefix = STATE.ghosts.some(g => String(g.answer).startsWith(nextInput));

            if (isPrefix) {
                globalInput = nextInput;
                inputDisplay.style.borderColor = "#00ff00"; // Green border for good input
                checkAnswerGlobal();
            } else {
                // Wrong input! Flash red and clear.
                globalInput = "";
                showErrorFeedback();
            }
            updateVisualInput();
        }

        function showErrorFeedback() {
            if (inputDisplay) {
                inputDisplay.style.borderColor = "red";
                inputDisplay.innerText = "XXX";
                setTimeout(updateVisualInput, 200);
            }
        }

        function checkAnswerGlobal() {
            const currentVal = parseInt(globalInput);
            // Must match exactly
            const matchIndex = STATE.ghosts.findIndex(g => g.answer === currentVal);

            if (matchIndex !== -1) {
                const ghost = STATE.ghosts[matchIndex];
                createPoof(ghost.x, ghost.y);
                ghost.element.remove();
                STATE.ghosts.splice(matchIndex, 1);
                STATE.score += 10;
                if (scoreEl) scoreEl.innerText = STATE.score;

                globalInput = ""; // Reset after kill
                updateVisualInput();
            }
        }

        function createPoof(x, y) {
            const poof = document.createElement('div');
            poof.classList.add('poof');
            poof.style.left = `${x}px`;
            poof.style.top = `${y}px`;
            if (container) container.appendChild(poof);
            setTimeout(() => poof.remove(), 500);
        }

        window.addEventListener('resize', () => { });

        // Auto-start for user convenience during debugging
        window.onload = function () {
            log("Auto-starting game in 1 second...");
            setTimeout(() => {
                log("Auto-start trigger");
                startGame();
            }, 1000);
        };

    </script>
    <div style="position:fixed; bottom:10px; right:10px; color:yellow; font-size:20px; z-index:99999;">VERSION:
        ENDLESS_EDITION</div>
</body>

</html>