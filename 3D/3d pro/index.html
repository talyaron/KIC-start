<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Runner 2077: Hunter Update</title>
    <link rel="stylesheet" href="style.css">

    <!-- Load Three.js and Addons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <style>
        #upgrade-menu {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }

        .upgrade-card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--neon-pink);
            padding: 10px;
            margin-top: 10px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 5px var(--neon-blue);
        }

        #health-bar-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid white;
            transform: skewX(-20deg);
        }

        #health-bar-fill {
            height: 100%;
            background: #00ff00;
            width: 100%;
            transition: width 0.2s, background-color 0.2s;
            box-shadow: 0 0 10px #00ff00;
        }

        .notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: yellow;
            text-shadow: 0 0 20px red;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .show-notif {
            opacity: 1;
        }

        .powerup-text {
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
        }
    </style>
</head>

<body>
    <div id="ui-container">
        <div id="health-bar-container">
            <div id="health-bar-fill"></div>
        </div>

        <div id="score-board">
            <div class="hud-item">DISTANCE: <span id="dist-display">0</span>m</div>
            <div class="hud-item">SCORE: <span id="score-display">0</span></div>
            <div class="hud-item">LVL: <span id="level-display">1</span></div>
            <div class="hud-item" style="font-size:0.8rem; margin-top:5px; color:#aaa">SHIFT = BARREL ROLL</div>
        </div>

        <div id="upgrade-menu" class="hidden">
            <h3 style="color: yellow">UPGRADE AVAILABLE (Press key)</h3>
            <div class="upgrade-card">[1] FIRE RATE (Speed++)</div>
            <div class="upgrade-card">[2] LASER POWER (Dmg++)</div>
            <div class="upgrade-card">[3] SHIELD REPAIR (HP+)</div>
        </div>

        <div id="game-notif" class="notification">LEVEL UP!</div>

        <div id="game-over" class="hidden">
            <h1>SYSTEM CRITICAL</h1>
            <p>FINAL SCORE: <span id="final-dist">0</span></p>
            <button id="restart-btn">REBOOT SYSTEM</button>
        </div>
        <div id="start-screen">
            <h1>NEON RUNNER 3.0.1</h1>
            <p>CLICK TO ENGAGE</p>
        </div>
    </div>
    <canvas id="game-canvas"></canvas>

    <script>
        const COLORS = { player: 0x00f3ff, enemy: 0xff0055, enemyBullet: 0xff4400, pickup: 0x00ffff, bg: 0x020205 };

        // --- HELPERS ---
        function randomRange(min, max) { return Math.random() * (max - min) + min; }
        function lerp(s, e, t) { return s * (1 - t) + e * t; }

        // --- AUDIO ---
        class AudioController {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.enabled = true;
            }
            playSound(type) {
                if (!this.enabled || this.ctx.state === 'suspended') this.ctx.resume();
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                if (type === 'shoot') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(880, t); osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    osc.start(t); osc.stop(t + 0.1);
                } else if (type === 'explode') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                    gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                    osc.start(t); osc.stop(t + 0.4);
                } else if (type === 'powerup') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(600, t); osc.frequency.linearRampToValueAtTime(1200, t + 0.3);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
                    osc.start(t); osc.stop(t + 0.3);
                } else if (type === 'warning') {
                    osc.type = 'square'; osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(150, t + 0.2);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.4);
                    osc.start(t); osc.stop(t + 0.4);
                }
            }
        }

        // --- PARTICLES ---
        class ParticleSystem {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
                this.geom = new THREE.DodecahedronGeometry(0.2);
            }
            explode(pos, count = 15, color = 0xffaa00) {
                const mat = new THREE.MeshBasicMaterial({ color: color });
                for (let i = 0; i < count; i++) {
                    const m = new THREE.Mesh(this.geom, mat);
                    m.position.copy(pos);
                    m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                    const v = new THREE.Vector3((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
                    this.scene.add(m);
                    this.particles.push({ mesh: m, vel: v, life: 1.0 });
                }
            }
            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= dt * 1.5;
                    if (p.life <= 0) { this.scene.remove(p.mesh); this.particles.splice(i, 1); }
                    else { p.mesh.position.addScaledVector(p.vel, dt); p.mesh.scale.setScalar(p.life); }
                }
            }
        }

        // --- PLAYER ---
        class Player {
            constructor(scene) {
                this.scene = scene;
                this.mesh = new THREE.Group();
                this.bullets = [];
                this.maxHp = 100; this.hp = 100;
                this.fireRate = 0.3; this.damage = 10; this.lastShot = 0;
                this.powerupTimer = 0;

                // Ship
                const body = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2, 4), new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3 }));
                body.rotation.x = Math.PI / 2;
                const cockpit = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.8), new THREE.MeshStandardMaterial({ color: 0x00f3ff, emissive: 0x00f3ff, emissiveIntensity: 0.8 }));
                cockpit.position.set(0, 0.3, 0.2);
                this.mesh.add(body, cockpit);
                this.mesh.position.y = 1;
                this.scene.add(this.mesh);
                this.box = new THREE.Box3();

                // Dodge Logic
                this.isDodging = false;
                this.dodgeTimer = 0;
                this.dodgeDir = 0;
            }

            update(dt, inputX) {
                // Movement
                let targetX = inputX * 8;

                // Dodge
                if (this.isDodging) {
                    this.dodgeTimer -= dt;
                    this.mesh.rotation.z += this.dodgeDir * dt * 20; // Barrel roll
                    if (this.dodgeTimer <= 0) {
                        this.isDodging = false;
                        this.mesh.rotation.z = 0;
                    }
                } else {
                    // Regular smooth moves
                    this.mesh.position.x = lerp(this.mesh.position.x, targetX, dt * 8);
                    this.mesh.rotation.z = (this.mesh.position.x - targetX) * 0.5;
                    this.mesh.rotation.y = -this.mesh.rotation.z * 0.5;
                }

                // Fire CD
                this.lastShot += dt;
                if (this.powerupTimer > 0) this.powerupTimer -= dt;

                this.box.setFromObject(this.mesh);
                this.box.expandByScalar(-0.3);

                // Update Bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const b = this.bullets[i];
                    b.position.z -= 80 * dt;
                    if (b.position.z < -100) { this.scene.remove(b); this.bullets.splice(i, 1); }
                }
            }

            shoot() {
                if (this.lastShot < this.fireRate) return;
                this.lastShot = 0;

                let shots = this.powerupTimer > 0 ? [-0.5, 0, 0.5] : [0];
                const geo = new THREE.BoxGeometry(0.15, 0.15, 0.8);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

                shots.forEach(offset => {
                    const b = new THREE.Mesh(geo, mat);
                    b.position.copy(this.mesh.position);
                    b.position.x += offset;
                    b.position.y -= 0.2;
                    this.scene.add(b);
                    this.bullets.push(b);
                });
                return true;
            }

            dodge(dir) {
                if (!this.isDodging) {
                    this.isDodging = true;
                    this.dodgeTimer = 0.4;
                    this.dodgeDir = dir || (Math.random() > 0.5 ? 1 : -1);
                    // Quick dash
                    this.mesh.position.x += this.dodgeDir * 3;
                }
            }

            reset() { this.hp = 100; this.fireRate = 0.3; this.damage = 10; this.mesh.position.x = 0; this.bullets.forEach(b => this.scene.remove(b)); this.bullets = []; }
        }

        // --- ENEMY SHIP (HUNTER) ---
        class HunterShip {
            constructor(scene) {
                this.scene = scene;
                this.mesh = new THREE.Group();
                this.active = false;
                this.hp = 0;
                this.strafeTimer = 0;
                this.bullets = [];

                // Model
                const body = new THREE.Mesh(new THREE.ConeGeometry(1, 4, 3), new THREE.MeshStandardMaterial({ color: 0xaa2222 }));
                body.rotation.x = -Math.PI / 2;
                body.scale.z = 0.5;
                const wings = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 1), new THREE.MeshStandardMaterial({ color: 0x550000 }));
                this.mesh.add(body, wings);
                this.scene.add(this.mesh);
                this.mesh.visible = false;
                this.box = new THREE.Box3();
            }

            spawn(zDist) {
                this.active = true;
                this.mesh.visible = true;
                this.hp = 150;
                this.mesh.position.set(0, 2, zDist); // Start far out
                this.shootTimer = 2.0;
            }

            update(dt, playerPos) {
                if (!this.active) return;

                // Hover distance
                let targetZ = -20;
                this.mesh.position.z = lerp(this.mesh.position.z, targetZ, dt * 1);

                // Strafe
                this.strafeTimer += dt;
                this.mesh.position.x = Math.sin(this.strafeTimer) * 5; // Move side to side

                // Shoot
                this.shootTimer -= dt;
                if (this.shootTimer <= 0) {
                    this.shoot(playerPos);
                    this.shootTimer = 2.5;
                }

                this.box.setFromObject(this.mesh);

                // Projectiles
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const b = this.bullets[i];
                    b.position.addScaledVector(b.userData.vel, dt);
                    if (b.position.z > 20) { this.scene.remove(b); this.bullets.splice(i, 1); }
                }
            }

            shoot(target) {
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: COLORS.enemyBullet }));
                b.position.copy(this.mesh.position);
                b.lookAt(target);

                // Calc velocity vector
                const dir = new THREE.Vector3().subVectors(target, this.mesh.position).normalize();
                b.userData = { vel: dir.multiplyScalar(20) }; // Slow projectile

                this.scene.add(b);
                this.bullets.push(b);
                // Trigger Warning Sound (if available)
            }

            reset() {
                this.active = false; this.mesh.visible = false;
                this.bullets.forEach(b => this.scene.remove(b)); this.bullets = [];
            }
        }

        // --- WORLD ---
        class World {
            constructor(scene) {
                this.scene = scene;
                this.speed = 20; // Slower base speed for scale
                this.pool = [];
                this.drops = []; // Powerups

                // Grids
                const g1 = new THREE.GridHelper(200, 50, COLORS.grid, 0x110022); g1.position.z = -50;
                const g2 = g1.clone(); g2.position.z = -250;
                this.scene.add(g1, g2); this.grids = [g1, g2];

                // Asteroids (Dodecahedron)
                const geo = new THREE.DodecahedronGeometry(1, 0);
                const mat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, emissive: 0x220000, emissiveIntensity: 0.3 });

                for (let i = 0; i < 30; i++) {
                    const m = new THREE.Mesh(geo, mat.clone());
                    m.visible = false; m.userData = { active: false, hp: 0, box: new THREE.Box3() };
                    this.scene.add(m); this.pool.push(m);
                }
                this.spawnTimer = 0;
            }

            update(dt) {
                const step = this.speed * dt;
                this.grids.forEach(g => { g.position.z += step; if (g.position.z > 50) g.position.z -= 400; });

                if (this.spawnTimer <= 0) {
                    this.spawnAsteroid();
                    this.spawnTimer = 2.0; // Slower spawn
                } else {
                    this.spawnTimer -= dt;
                }

                this.pool.forEach(a => {
                    if (a.userData.active) {
                        a.position.z += step;
                        a.rotation.x += dt; a.rotation.y += dt;
                        a.userData.box.setFromObject(a);
                        if (a.position.z > 10) { a.visible = false; a.userData.active = false; }
                    }
                });

                // Updates drops
                for (let i = this.drops.length - 1; i >= 0; i--) {
                    const d = this.drops[i];
                    d.position.z += step;
                    d.rotation.y += dt * 2;
                    d.userData.box.setFromObject(d);
                    if (d.position.z > 10) { this.scene.remove(d); this.drops.splice(i, 1); }
                }
            }

            spawnAsteroid() {
                const a = this.pool.find(x => !x.userData.active);
                if (!a) return;
                // Randomize
                const scale = randomRange(0.8, 2.5);
                a.scale.setScalar(scale);
                a.userData.hp = scale * 20;
                a.userData.score = scale * 50;
                a.visible = true; a.userData.active = true;
                a.position.set((Math.random() - 0.5) * 20, randomRange(1, 3), -150);
            }

            spawnDrop(pos) {
                const geo = new THREE.OctahedronGeometry(0.5);
                const mat = new THREE.MeshStandardMaterial({ color: COLORS.pickup, emissive: COLORS.pickup, emissiveIntensity: 2 });
                const m = new THREE.Mesh(geo, mat);
                m.position.copy(pos);
                m.userData = { box: new THREE.Box3(), type: 'tripleshot' };
                this.scene.add(m);
                this.drops.push(m);
            }

            reset() {
                this.pool.forEach(a => { a.visible = false; a.userData.active = false; });
                this.drops.forEach(d => this.scene.remove(d)); this.drops = [];
            }
        }

        // --- GAME ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(COLORS.bg);
                this.scene.fog = new THREE.FogExp2(COLORS.bg, 0.02);
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
                this.camera.position.set(0, 4, 8); this.camera.lookAt(0, 0, -5);

                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                // FX
                this.composer = new THREE.EffectComposer(this.renderer);
                this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));
                this.composer.addPass(new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85));

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(5, 10, 5); this.scene.add(dl);

                this.audio = new AudioController();
                this.player = new Player(this.scene);
                this.world = new World(this.scene);
                this.hunter = new HunterShip(this.scene);
                this.particles = new ParticleSystem(this.scene);

                this.state = 'MENU';
                this.score = 0; this.upgradePoints = 0; this.nextUpgrade = 1000;
                this.timeWarp = 1.0;

                // UI
                this.ui = { start: document.getElementById('start-screen'), hp: document.getElementById('health-bar-fill'), score: document.getElementById('score-display'), over: document.getElementById('game-over'), notif: document.getElementById('game-notif') };

                window.addEventListener('mousemove', e => this.inputX = (e.clientX / window.innerWidth) * 2 - 1);
                window.addEventListener('keydown', e => {
                    if (e.code === 'Space' && this.state === 'PLAYING') this.player.shoot() && this.audio.playSound('shoot');
                    if (e.shiftKey && this.state === 'PLAYING') this.player.dodge();
                    if (this.upgradePoints > 0) {
                        if (e.key === '1') this.applyUpgrade('rate'); if (e.key === '2') this.applyUpgrade('damage'); if (e.key === '3') this.applyUpgrade('heal');
                    }
                });
                this.ui.start.addEventListener('click', () => this.start());
                document.getElementById('restart-btn').addEventListener('click', () => this.start());

                this.hunterTimer = 15.0;
                this.clock = new THREE.Clock();
                this.animate();
            }

            start() {
                this.state = 'PLAYING'; this.score = 0; this.upgradePoints = 0;
                this.player.reset(); this.world.reset(); this.hunter.reset();
                this.ui.start.classList.add('hidden'); this.ui.over.classList.add('hidden');
                this.audio.ctx.resume();
            }

            notify(text, type = '') {
                this.ui.notif.textContent = text; this.ui.notif.className = 'notification show-notif ' + type;
                setTimeout(() => this.ui.notif.classList.remove('show-notif'), 2000);
            }

            applyUpgrade(t) { this.upgradePoints--; this.notify("UPGRADE APPLIED"); /* simplify logic */ }

            updateLogic(dt) {
                // Time Warp Logic
                dt *= this.timeWarp;
                this.timeWarp = lerp(this.timeWarp, 1.0, dt * 2);

                this.player.update(dt, this.inputX || 0);
                this.world.update(dt);
                this.particles.update(dt);

                // Hunter Logic
                if (!this.hunter.active) {
                    this.hunterTimer -= dt;
                    if (this.hunterTimer <= 0) {
                        this.hunter.spawn(-60); // Appear
                        this.notify("WARNING: HUNTER SHIP", "powerup-text");
                        this.audio.playSound('warning');
                    }
                } else {
                    this.hunter.update(dt, this.player.mesh.position);
                }

                this.checkCollisions();

                // UI
                this.ui.score.innerText = Math.floor(this.score);
                this.ui.hp.style.width = (this.player.hp) + "%";
            }

            checkCollisions() {
                // 1. Players Bullets
                for (let i = this.player.bullets.length - 1; i >= 0; i--) {
                    const b = this.player.bullets[i];
                    const bBox = new THREE.Box3().setFromObject(b);

                    // Vs Asteroids
                    for (let a of this.world.pool) {
                        if (a.userData.active && bBox.intersectsBox(a.userData.box)) {
                            this.damageObject(a, this.player.damage, b, i); return;
                        }
                    }
                    // Vs Hunter
                    if (this.hunter.active && bBox.intersectsBox(this.hunter.box)) {
                        this.hunter.hp -= this.player.damage;
                        if (this.hunter.hp <= 0) {
                            this.hunter.reset();
                            this.particles.explode(this.hunter.mesh.position, 30, 0xffaa00);
                            this.score += 500;
                            this.timeWarp = 0.2; // Slow mo!
                            this.audio.playSound('explode');
                            this.hunterTimer = 20.0;
                        }
                        this.scene.remove(b); this.player.bullets.splice(i, 1);
                        return;
                    }
                }

                // 2. Player vs Environment
                if (!this.player.isDodging) {
                    // Vs Asteroids
                    for (let a of this.world.pool) {
                        if (a.userData.active && this.player.box.intersectsBox(a.userData.box)) {
                            this.player.hp -= 20;
                            this.particles.explode(a.position, 10, 0x555555);
                            a.visible = false; a.userData.active = false;
                            if (this.player.hp <= 0) this.gameOver();
                        }
                    }
                    // Vs Hunter Bullets
                    for (let b of this.hunter.bullets) {
                        if (new THREE.Box3().setFromObject(b).intersectsBox(this.player.box)) {
                            this.player.hp -= 15;
                            this.scene.remove(b);
                            // ...remove from array tricky here without proper loop
                            // For simplicity, collision logic is slightly simplified
                            if (this.player.hp <= 0) this.gameOver();
                        }
                    }
                    // Vs Powerups
                    for (let i = this.world.drops.length - 1; i >= 0; i--) {
                        let d = this.world.drops[i];
                        if (this.player.box.intersectsBox(d.userData.box)) {
                            this.player.powerupTimer = 5.0; // 5s triple shot
                            this.notify("TRIPLE SHOT!", "powerup-text");
                            this.audio.playSound('powerup');
                            this.scene.remove(d); this.world.drops.splice(i, 1);
                        }
                    }
                }
            }

            damageObject(obj, dmg, bullet, bIdx) {
                obj.userData.hp -= dmg;
                obj.material.emissiveIntensity = 2;
                setTimeout(() => obj.material.emissiveIntensity = 0.3, 50);

                this.scene.remove(bullet); this.player.bullets.splice(bIdx, 1);

                if (obj.userData.hp <= 0) {
                    obj.visible = false; obj.userData.active = false; obj.position.z = -500;
                    this.particles.explode(obj.position, 15, obj.material.color);
                    this.audio.playSound('explode');
                    this.score += obj.userData.score;
                    if (Math.random() > 0.8) this.world.spawnDrop(obj.position); // Chance for loot
                }
            }

            gameOver() { this.state = 'GAMEOVER'; this.ui.over.classList.remove('hidden'); }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                const dt = Math.min(this.clock.getDelta(), 0.1);
                if (this.state === 'PLAYING') this.updateLogic(dt);
                this.composer.render();
            }
        }
        new Game();
    </script>
</body>

</html>