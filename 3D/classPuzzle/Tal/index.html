<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Fighter - Balloon Hunter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .hud-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            padding: 15px;
            color: #fff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #score-panel {
            top: 20px;
            left: 20px;
        }

        #score-value {
            font-size: 36px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
        }

        #health-panel {
            top: 20px;
            right: 20px;
        }

        #health-bar {
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            border-radius: 10px;
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        #flight-panel {
            bottom: 20px;
            left: 20px;
        }

        #flight-panel .stat {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 5px 0;
        }

        #flight-panel .value {
            color: #00ff00;
            font-weight: bold;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 0, 0, 0.8);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }

        #crosshair::before {
            width: 20px;
            height: 2px;
            left: -10px;
            top: -1px;
        }

        #crosshair::after {
            width: 2px;
            height: 20px;
            left: -1px;
            top: -10px;
        }

        #crosshair-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff0000;
            border-radius: 50%;
            left: -2px;
            top: -2px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 1);
        }

        /* Damage Effect */
        #damage-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.6) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        }

        /* Cockpit Frame */
        #cockpit-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            border: 40px solid #1a1a1a;
            border-radius: 50px;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
        }

        #cockpit-frame-top {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 30px;
            background: #222;
            border-radius: 0 0 20px 20px;
        }

        #cockpit-frame-bottom {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            background: linear-gradient(to top, #1a1a1a, transparent);
        }

        /* Start Screen */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a2e 0%, #1a0a3e 50%, #0a1a3e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            cursor: pointer;
        }

        #start-screen h1 {
            font-size: 72px;
            color: #fff;
            text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        #start-screen h2 {
            font-size: 36px;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            margin-bottom: 40px;
        }

        #start-screen .instructions {
            background: rgba(0, 0, 0, 0.5);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            margin-bottom: 40px;
        }

        #start-screen .instructions p {
            color: #aaa;
            font-size: 18px;
            margin: 10px 0;
        }

        #start-screen .instructions span {
            color: #00ffff;
            font-weight: bold;
        }

        #start-screen .click-to-start {
            font-size: 28px;
            color: #fff;
            animation: blink 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Game Over Screen */
        #game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            cursor: pointer;
        }

        #game-over h1 {
            font-size: 72px;
            color: #ff0000;
            text-shadow: 0 0 30px #ff0000;
            margin-bottom: 20px;
        }

        #game-over .final-score {
            font-size: 48px;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            margin-bottom: 40px;
        }

        #game-over .restart {
            font-size: 24px;
            color: #fff;
            animation: blink 1s infinite;
        }

        /* Message display */
        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -100px);
            font-size: 32px;
            color: #fff;
            text-shadow: 0 0 20px #00ffff;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 102;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-panel" id="score-panel">
            <div>SCORE</div>
            <div id="score-value">0</div>
        </div>

        <div class="hud-panel" id="health-panel">
            <div>HEALTH</div>
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
        </div>

        <div class="hud-panel" id="flight-panel">
            <div class="stat">
                <span>ALTITUDE:</span>
                <span class="value" id="altitude-value">0</span>
            </div>
            <div class="stat">
                <span>SPEED:</span>
                <span class="value" id="speed-value">0</span>
            </div>
            <div class="stat">
                <span>BALLOONS:</span>
                <span class="value" id="balloon-count">0</span>
            </div>
        </div>
    </div>

    <!-- Crosshair -->
    <div id="crosshair">
        <div id="crosshair-dot"></div>
    </div>

    <!-- Damage Overlay -->
    <div id="damage-overlay"></div>

    <!-- Cockpit Frame -->
    <div id="cockpit-overlay">
        <div id="cockpit-frame-top"></div>
        <div id="cockpit-frame-bottom"></div>
    </div>

    <!-- Message -->
    <div id="message"></div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>SKY FIGHTER</h1>
        <h2>Balloon Hunter</h2>
        <div class="instructions">
            <p><span>W/S</span> or <span>Up/Down</span> - Pitch (nose up/down)</p>
            <p><span>A/D</span> or <span>Left/Right</span> - Roll (bank left/right)</p>
            <p><span>Mouse</span> - Look around cockpit</p>
            <p><span>Click</span> or <span>Space</span> - Shoot</p>
            <p><span>ESC</span> - Pause</p>
        </div>
        <div class="click-to-start">CLICK TO START</div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over">
        <h1>GAME OVER</h1>
        <div class="final-score">Score: <span id="final-score">0</span></div>
        <div class="restart">Click to restart</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            // Player
            PLANE_MIN_SPEED: 40,
            PLANE_MAX_SPEED: 120,
            PLANE_ACCELERATION: 15,
            PITCH_SPEED: 1.5,
            ROLL_SPEED: 2.5,
            YAW_FROM_ROLL: 0.8,
            LOOK_SENSITIVITY: 0.002,
            LOOK_MAX_X: Math.PI / 3,
            LOOK_MAX_Y: Math.PI / 4,
            PLAYER_MAX_HEALTH: 100,

            // Shooting
            FIRE_RATE: 0.12,
            BULLET_SPEED: 300,
            BULLET_LIFETIME: 2,

            // Balloons
            BALLOON_COUNT: 25,
            BALLOON_SPAWN_RADIUS: 300,
            BALLOON_MIN_HEIGHT: 40,
            BALLOON_MAX_HEIGHT: 180,
            BALLOON_FLOAT_SPEED: 0.8,
            BALLOON_FLOAT_AMPLITUDE: 3,

            // AA Cannons
            AA_CANNON_COUNT: 6,
            AA_FIRE_RATE: 1.4,
            AA_BASE_ACCURACY: 0.02,      // Very accurate when player flies straight
            AA_DODGE_ACCURACY: 0.25,     // Less accurate when player is dodging
            AA_RANGE: 350,
            AA_TRACKING_SPEED: 1.2,
            AA_BULLET_SPEED: 220,
            AA_DAMAGE: 15,
            AA_PREDICTION_TIME: 1.2,     // How far ahead to predict

            // Environment
            WORLD_SIZE: 800,
            CLOUD_COUNT: 30,
            TREE_COUNT: 80,

            // Audio
            MASTER_VOLUME: 0.6
        };

        // ==================== AUDIO MANAGER ====================
        class AudioManager {
            constructor() {
                this.context = null;
                this.masterGain = null;
                this.engineOsc = null;
                this.engineGain = null;
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return;

                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.context.createGain();
                this.masterGain.gain.value = CONFIG.MASTER_VOLUME;
                this.masterGain.connect(this.context.destination);

                await this.context.resume();
                this.initialized = true;

                this.startEngine();
            }

            startEngine() {
                // Create engine sound with multiple oscillators
                const osc1 = this.context.createOscillator();
                osc1.type = 'sawtooth';
                osc1.frequency.value = 80;

                const osc2 = this.context.createOscillator();
                osc2.type = 'square';
                osc2.frequency.value = 160;

                const osc3 = this.context.createOscillator();
                osc3.type = 'triangle';
                osc3.frequency.value = 40;

                // LFO for wobble
                const lfo = this.context.createOscillator();
                lfo.frequency.value = 6;
                const lfoGain = this.context.createGain();
                lfoGain.gain.value = 5;
                lfo.connect(lfoGain);
                lfoGain.connect(osc1.frequency);

                // Filter
                const filter = this.context.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 300;
                filter.Q.value = 2;

                // Gains
                const gain1 = this.context.createGain();
                gain1.gain.value = 0.15;
                const gain2 = this.context.createGain();
                gain2.gain.value = 0.08;
                const gain3 = this.context.createGain();
                gain3.gain.value = 0.1;

                this.engineGain = this.context.createGain();
                this.engineGain.gain.value = 0.3;

                osc1.connect(gain1);
                osc2.connect(gain2);
                osc3.connect(gain3);
                gain1.connect(filter);
                gain2.connect(filter);
                gain3.connect(filter);
                filter.connect(this.engineGain);
                this.engineGain.connect(this.masterGain);

                osc1.start();
                osc2.start();
                osc3.start();
                lfo.start();

                this.engineOsc = { osc1, osc2, osc3, lfo, filter };
            }

            updateEngine(speed) {
                if (!this.engineOsc) return;
                const speedRatio = (speed - CONFIG.PLANE_MIN_SPEED) / (CONFIG.PLANE_MAX_SPEED - CONFIG.PLANE_MIN_SPEED);
                const freq = 70 + speedRatio * 80;
                this.engineOsc.osc1.frequency.setTargetAtTime(freq, this.context.currentTime, 0.1);
                this.engineOsc.osc2.frequency.setTargetAtTime(freq * 2, this.context.currentTime, 0.1);
                this.engineOsc.filter.frequency.setTargetAtTime(250 + speedRatio * 200, this.context.currentTime, 0.1);
            }

            playShoot() {
                if (!this.initialized) return;

                const duration = 0.08;
                const bufferSize = this.context.sampleRate * duration;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    const envelope = Math.exp(-t * 15);
                    data[i] = (Math.random() * 2 - 1) * envelope;
                }

                const source = this.context.createBufferSource();
                source.buffer = buffer;

                const filter = this.context.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;

                const gain = this.context.createGain();
                gain.gain.value = 0.4;

                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                source.start();
            }

            playPop(pitch = 1) {
                if (!this.initialized) return;

                // Pop transient
                const duration = 0.25;
                const bufferSize = this.context.sampleRate * duration;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    const t = i / this.context.sampleRate;
                    // Initial pop
                    let sample = 0;
                    if (t < 0.01) {
                        sample = (Math.random() * 2 - 1) * (1 - t / 0.01);
                    }
                    // Descending whistle
                    const freq = 800 * Math.exp(-t * 8);
                    sample += Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 6) * 0.5;
                    data[i] = sample;
                }

                const source = this.context.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = pitch;

                const gain = this.context.createGain();
                gain.gain.value = 0.6;

                source.connect(gain);
                gain.connect(this.masterGain);
                source.start();
            }

            playAAFire() {
                if (!this.initialized) return;

                // Deep boom sound
                const osc = this.context.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, this.context.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.context.currentTime + 0.2);

                // Noise component
                const noiseBuffer = this.context.createBuffer(1, this.context.sampleRate * 0.15, this.context.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / noiseData.length * 3);
                }
                const noiseSource = this.context.createBufferSource();
                noiseSource.buffer = noiseBuffer;

                const filter = this.context.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;

                const gain = this.context.createGain();
                gain.gain.setValueAtTime(0.3, this.context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

                osc.connect(gain);
                noiseSource.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.context.currentTime + 0.3);
                noiseSource.start();
            }

            playHit() {
                if (!this.initialized) return;

                // Metal impact
                const osc = this.context.createOscillator();
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, this.context.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.context.currentTime + 0.1);

                const gain = this.context.createGain();
                gain.gain.setValueAtTime(0.5, this.context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.context.currentTime + 0.15);
            }

            playExplosion() {
                if (!this.initialized) return;

                const duration = 0.5;
                const bufferSize = this.context.sampleRate * duration;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 5);
                }

                const source = this.context.createBufferSource();
                source.buffer = buffer;

                const filter = this.context.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                const gain = this.context.createGain();
                gain.gain.value = 0.7;

                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                source.start();
            }
        }

        // ==================== GAME STATE ====================
        const gameState = {
            isRunning: false,
            isPaused: false,
            score: 0,
            health: CONFIG.PLAYER_MAX_HEALTH,
            gameTime: 0,
            lastFireTime: 0,

            // Player state
            position: new THREE.Vector3(0, 100, 0),
            velocity: new THREE.Vector3(0, 0, -CONFIG.PLANE_MIN_SPEED),
            rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
            speed: CONFIG.PLANE_MIN_SPEED + 20,
            pitch: 0,
            roll: 0,
            yaw: 0,
            lookX: 0,
            lookY: 0,

            // For AA cannon prediction - track direction changes
            velocityHistory: [],
            directionChangeAmount: 0,  // 0 = flying straight, higher = dodging
            lastVelocity: new THREE.Vector3(0, 0, -1)
        };

        // Input state
        const keys = {
            w: false, s: false, a: false, d: false,
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            Space: false
        };
        let mouseDown = false;

        // ==================== THREE.JS SETUP ====================
        const canvas = document.getElementById('game-canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));  // Cap at 2 for performance
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const clock = new THREE.Clock();
        const audioManager = new AudioManager();

        // Entity arrays
        const balloons = [];
        const bullets = [];
        const aaCannons = [];
        const particles = [];
        const tracers = [];
        const trains = [];

        // ==================== LIGHTING ====================
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x6688cc, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
            sunLight.position.set(100, 200, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.near = 10;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            scene.add(sunLight);

            // Hemisphere light for sky color
            const hemiLight = new THREE.HemisphereLight(0x88ccff, 0x44aa44, 0.4);
            scene.add(hemiLight);
        }

        // ==================== SKY ====================
        function createSky() {
            const skyGeometry = new THREE.SphereGeometry(900, 32, 32);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0066ff) },
                    bottomColor: { value: new THREE.Color(0x99ccff) },
                    offset: { value: 20 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide,
                depthWrite: false
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }

        // ==================== CLOUDS ====================
        function createClouds() {
            const cloudGroup = new THREE.Group();

            for (let i = 0; i < CONFIG.CLOUD_COUNT; i++) {
                const cloud = createSingleCloud();
                cloud.position.set(
                    (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 2,
                    80 + Math.random() * 150,
                    (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 2
                );
                cloud.userData.driftSpeed = 0.5 + Math.random() * 1;
                cloudGroup.add(cloud);
            }

            scene.add(cloudGroup);
            return cloudGroup;
        }

        function createSingleCloud() {
            const group = new THREE.Group();
            const material = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.85
            });

            const sphereCount = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < sphereCount; i++) {
                const radius = 5 + Math.random() * 6;
                const geo = new THREE.SphereGeometry(radius, 6, 4);
                const sphere = new THREE.Mesh(geo, material);
                sphere.position.set(
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 12
                );
                group.add(sphere);
            }

            return group;
        }

        // ==================== TERRAIN ====================
        function getTerrainHeight(x, z) {
            return Math.sin(x * 0.015) * Math.cos(z * 0.015) * 15 +
                   Math.sin(x * 0.03) * Math.cos(z * 0.025) * 8;
        }

        function createTerrain() {
            // Ground with higher resolution
            const groundGeo = new THREE.PlaneGeometry(CONFIG.WORLD_SIZE * 2, CONFIG.WORLD_SIZE * 2, 60, 60);
            const vertices = groundGeo.attributes.position.array;

            // Add height variation
            for (let i = 2; i < vertices.length; i += 3) {
                const x = vertices[i - 2];
                const z = vertices[i - 1];
                vertices[i] = getTerrainHeight(x, z);
            }
            groundGeo.computeVertexNormals();

            const groundMat = new THREE.MeshPhongMaterial({
                color: 0x3d8b3d,
                flatShading: false,
                shininess: 5
            });

            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create roads
            createRoads();

            // Create railroad tracks and trains
            createRailroads();

            // Trees (avoid roads and tracks)
            for (let i = 0; i < CONFIG.TREE_COUNT; i++) {
                const tree = createTree();
                let x, z;
                do {
                    x = (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 1.8;
                    z = (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 1.8;
                } while (isOnRoadOrTrack(x, z));
                const y = getTerrainHeight(x, z);
                tree.position.set(x, y, z);
                scene.add(tree);
            }
        }

        function isOnRoadOrTrack(x, z) {
            // Check if position is on main roads
            if (Math.abs(x) < 12) return true;  // North-South road
            if (Math.abs(z) < 12) return true;  // East-West road
            if (Math.abs(x - z) < 15) return true;  // Diagonal railroad
            if (Math.abs(z - 200) < 12 && x > -300 && x < 300) return true;  // Secondary road
            return false;
        }

        // ==================== ROADS ====================
        function createRoads() {
            const roadMat = new THREE.MeshPhongMaterial({
                color: 0x333333,
                shininess: 10
            });
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

            // Main North-South road
            createRoad(0, 0, CONFIG.WORLD_SIZE * 1.8, 0, roadMat, lineMat, whiteMat);

            // Main East-West road
            createRoad(0, Math.PI / 2, CONFIG.WORLD_SIZE * 1.8, 0, roadMat, lineMat, whiteMat);

            // Secondary road
            createRoad(0, Math.PI / 2, 600, 200, roadMat, lineMat, whiteMat);

            // Curved road
            createCurvedRoad(-200, -200, 150, Math.PI / 2, roadMat);
        }

        function createRoad(centerX, rotation, length, offsetZ, roadMat, lineMat, whiteMat) {
            const roadWidth = 20;
            const roadGeo = new THREE.PlaneGeometry(roadWidth, length, 1, Math.floor(length / 10));

            // Adjust vertices to follow terrain
            const vertices = roadGeo.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const localX = vertices[i];
                const localZ = vertices[i + 1];

                // Transform to world coordinates
                const cos = Math.cos(rotation);
                const sin = Math.sin(rotation);
                const worldX = centerX + localX * cos - localZ * sin;
                const worldZ = offsetZ + localX * sin + localZ * cos;

                vertices[i + 2] = getTerrainHeight(worldX, worldZ) + 0.2;
            }
            roadGeo.computeVertexNormals();

            const road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.rotation.z = rotation;
            road.position.set(centerX, 0, offsetZ);
            road.receiveShadow = true;
            scene.add(road);

            // Center line (dashed yellow)
            const dashCount = Math.floor(length / 20);
            for (let i = 0; i < dashCount; i++) {
                const dashGeo = new THREE.PlaneGeometry(0.4, 8);
                const dash = new THREE.Mesh(dashGeo, lineMat);
                dash.rotation.x = -Math.PI / 2;
                dash.rotation.z = rotation;

                const offset = (i - dashCount / 2) * 20 + 10;
                const cos = Math.cos(rotation);
                const sin = Math.sin(rotation);
                const worldX = centerX - offset * sin;
                const worldZ = offsetZ + offset * cos;

                dash.position.set(worldX, getTerrainHeight(worldX, worldZ) + 0.3, worldZ);
                scene.add(dash);
            }

            // Edge lines (white)
            for (let side = -1; side <= 1; side += 2) {
                const edgeGeo = new THREE.PlaneGeometry(0.3, length);
                const edge = new THREE.Mesh(edgeGeo, whiteMat);
                edge.rotation.x = -Math.PI / 2;
                edge.rotation.z = rotation;

                const cos = Math.cos(rotation);
                const sin = Math.sin(rotation);
                const offsetX = side * (roadWidth / 2 - 1) * cos;
                const offsetZPos = side * (roadWidth / 2 - 1) * sin;

                edge.position.set(centerX + offsetX, 0.25, offsetZ + offsetZPos);
                scene.add(edge);
            }
        }

        function createCurvedRoad(centerX, centerZ, radius, startAngle, roadMat) {
            const segments = 20;
            const roadWidth = 18;

            for (let i = 0; i < segments; i++) {
                const angle1 = startAngle + (i / segments) * Math.PI / 2;
                const angle2 = startAngle + ((i + 1) / segments) * Math.PI / 2;

                const x1 = centerX + Math.cos(angle1) * radius;
                const z1 = centerZ + Math.sin(angle1) * radius;
                const x2 = centerX + Math.cos(angle2) * radius;
                const z2 = centerZ + Math.sin(angle2) * radius;

                const segGeo = new THREE.PlaneGeometry(roadWidth, 15);
                const seg = new THREE.Mesh(segGeo, roadMat);
                seg.rotation.x = -Math.PI / 2;
                seg.rotation.z = -angle1 - Math.PI / 2;
                seg.position.set((x1 + x2) / 2, getTerrainHeight((x1 + x2) / 2, (z1 + z2) / 2) + 0.2, (z1 + z2) / 2);
                scene.add(seg);
            }
        }

        // ==================== RAILROADS ====================
        function createRailroads() {
            // Main diagonal railroad
            createRailTrack(-400, -400, 400, 400);

            // Spawn trains on the track
            createTrain(-200, -200, Math.PI / 4, 1);
            createTrain(100, 100, Math.PI / 4 + Math.PI, -1);
        }

        function createRailTrack(x1, z1, x2, z2) {
            const trackGroup = new THREE.Group();

            const dx = x2 - x1;
            const dz = z2 - z1;
            const length = Math.sqrt(dx * dx + dz * dz);
            const angle = Math.atan2(dx, dz);

            // Rails (metal)
            const railMat = new THREE.MeshPhongMaterial({
                color: 0x666666,
                shininess: 80,
                specular: 0x888888
            });

            // Sleepers (wooden ties)
            const sleeperMat = new THREE.MeshPhongMaterial({ color: 0x4a3728 });

            const sleeperCount = Math.floor(length / 8);
            const railGauge = 3;  // Distance between rails

            for (let i = 0; i < sleeperCount; i++) {
                const t = i / sleeperCount;
                const x = x1 + dx * t;
                const z = z1 + dz * t;
                const y = getTerrainHeight(x, z) + 0.3;

                // Sleeper
                const sleeperGeo = new THREE.BoxGeometry(6, 0.4, 1.2);
                const sleeper = new THREE.Mesh(sleeperGeo, sleeperMat);
                sleeper.position.set(x, y, z);
                sleeper.rotation.y = angle;
                sleeper.castShadow = true;
                sleeper.receiveShadow = true;
                trackGroup.add(sleeper);
            }

            // Rails
            for (let side = -1; side <= 1; side += 2) {
                const railPoints = [];
                const railSegments = 50;

                for (let i = 0; i <= railSegments; i++) {
                    const t = i / railSegments;
                    const x = x1 + dx * t;
                    const z = z1 + dz * t;
                    const y = getTerrainHeight(x, z) + 0.5;

                    // Offset perpendicular to track
                    const perpX = -Math.sin(angle) * side * railGauge / 2;
                    const perpZ = Math.cos(angle) * side * railGauge / 2;

                    railPoints.push(new THREE.Vector3(x + perpX, y, z + perpZ));
                }

                const railCurve = new THREE.CatmullRomCurve3(railPoints);
                const railGeo = new THREE.TubeGeometry(railCurve, 100, 0.15, 8, false);
                const rail = new THREE.Mesh(railGeo, railMat);
                rail.castShadow = true;
                trackGroup.add(rail);
            }

            // Gravel bed
            const gravelMat = new THREE.MeshPhongMaterial({ color: 0x666655 });
            const gravelGeo = new THREE.PlaneGeometry(8, length);
            const gravel = new THREE.Mesh(gravelGeo, gravelMat);
            gravel.rotation.x = -Math.PI / 2;
            gravel.rotation.z = angle;
            gravel.position.set((x1 + x2) / 2, getTerrainHeight((x1 + x2) / 2, (z1 + z2) / 2) + 0.1, (z1 + z2) / 2);
            trackGroup.add(gravel);

            scene.add(trackGroup);
        }

        // ==================== TRAINS ====================
        function createTrain(startX, startZ, angle, direction) {
            const trainGroup = new THREE.Group();

            // Locomotive
            const locoGroup = createLocomotive();
            trainGroup.add(locoGroup);

            // Cargo cars
            const carCount = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < carCount; i++) {
                const car = createCargoCar(i);
                car.position.z = -(i + 1) * 18;
                trainGroup.add(car);
            }

            // Caboose at end
            const caboose = createCaboose();
            caboose.position.z = -(carCount + 1) * 18;
            trainGroup.add(caboose);

            trainGroup.position.set(startX, getTerrainHeight(startX, startZ) + 1, startZ);
            trainGroup.rotation.y = angle;

            trainGroup.userData = {
                startX: -400,
                startZ: -400,
                endX: 400,
                endZ: 400,
                progress: 0.5 + (direction > 0 ? -0.3 : 0.3),
                speed: 0.015 + Math.random() * 0.01,
                direction: direction
            };

            scene.add(trainGroup);
            trains.push(trainGroup);
        }

        function createLocomotive() {
            const group = new THREE.Group();

            // Body
            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0xcc2222,
                shininess: 60
            });
            const bodyGeo = new THREE.BoxGeometry(5, 6, 16);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 4;
            body.castShadow = true;
            group.add(body);

            // Cabin
            const cabinMat = new THREE.MeshPhongMaterial({ color: 0xdd3333 });
            const cabinGeo = new THREE.BoxGeometry(5, 4, 6);
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 8, -3);
            cabin.castShadow = true;
            group.add(cabin);

            // Cabin windows
            const windowMat = new THREE.MeshPhongMaterial({
                color: 0x88ccff,
                shininess: 100,
                transparent: true,
                opacity: 0.7
            });
            for (let side = -1; side <= 1; side += 2) {
                const windowGeo = new THREE.PlaneGeometry(0.1, 2, 3);
                const window = new THREE.Mesh(windowGeo, windowMat);
                window.position.set(side * 2.6, 8.5, -3);
                window.rotation.y = side * Math.PI / 2;
                group.add(window);
            }

            // Smokestack
            const stackMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const stackGeo = new THREE.CylinderGeometry(0.6, 0.8, 3, 8);
            const stack = new THREE.Mesh(stackGeo, stackMat);
            stack.position.set(0, 9, 4);
            stack.castShadow = true;
            group.add(stack);

            // Headlight
            const lightMat = new THREE.MeshPhongMaterial({
                color: 0xffffaa,
                emissive: 0xffffaa,
                emissiveIntensity: 0.5
            });
            const lightGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
            const headlight = new THREE.Mesh(lightGeo, lightMat);
            headlight.position.set(0, 5, 8.2);
            headlight.rotation.x = Math.PI / 2;
            group.add(headlight);

            // Wheels
            createTrainWheels(group, 4);

            // Cow catcher
            const catcherMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const catcherGeo = new THREE.BoxGeometry(5, 1.5, 3);
            const catcher = new THREE.Mesh(catcherGeo, catcherMat);
            catcher.position.set(0, 1.5, 9);
            catcher.castShadow = true;
            group.add(catcher);

            return group;
        }

        function createCargoCar(index) {
            const group = new THREE.Group();

            // Random cargo car colors
            const carColors = [0x8b4513, 0x2e5a1c, 0x4a4a4a, 0x1e3a5f, 0x5c3317];
            const carMat = new THREE.MeshPhongMaterial({
                color: carColors[index % carColors.length],
                shininess: 20
            });

            // Car body
            const bodyGeo = new THREE.BoxGeometry(5, 5, 14);
            const body = new THREE.Mesh(bodyGeo, carMat);
            body.position.y = 4;
            body.castShadow = true;
            group.add(body);

            // Some cars have open tops with cargo
            if (Math.random() > 0.5) {
                const cargoColors = [0xffdd44, 0x8b4513, 0x333333];
                const cargoMat = new THREE.MeshPhongMaterial({
                    color: cargoColors[Math.floor(Math.random() * cargoColors.length)]
                });
                const cargoGeo = new THREE.BoxGeometry(4, 2, 12);
                const cargo = new THREE.Mesh(cargoGeo, cargoMat);
                cargo.position.y = 7.5;
                cargo.castShadow = true;
                group.add(cargo);
            }

            // Wheels
            createTrainWheels(group, 3);

            return group;
        }

        function createCaboose() {
            const group = new THREE.Group();

            // Body
            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0xcc4444,
                shininess: 40
            });
            const bodyGeo = new THREE.BoxGeometry(5, 4, 12);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 3.5;
            body.castShadow = true;
            group.add(body);

            // Cupola (raised section)
            const cupolaGeo = new THREE.BoxGeometry(3, 2, 4);
            const cupola = new THREE.Mesh(cupolaGeo, bodyMat);
            cupola.position.y = 6.5;
            cupola.castShadow = true;
            group.add(cupola);

            // Windows
            const windowMat = new THREE.MeshPhongMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.7
            });
            for (let side = -1; side <= 1; side += 2) {
                const windowGeo = new THREE.PlaneGeometry(0.1, 1.5, 3);
                const window = new THREE.Mesh(windowGeo, windowMat);
                window.position.set(side * 2.6, 3.5, 0);
                window.rotation.y = side * Math.PI / 2;
                group.add(window);
            }

            // Rear platform
            const platformMat = new THREE.MeshPhongMaterial({ color: 0x4a3728 });
            const platformGeo = new THREE.BoxGeometry(5, 0.3, 2);
            const platform = new THREE.Mesh(platformGeo, platformMat);
            platform.position.set(0, 1.5, -7);
            group.add(platform);

            // Railings
            const railMat = new THREE.MeshPhongMaterial({ color: 0x666666 });
            for (let side = -1; side <= 1; side += 2) {
                const railGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
                const rail = new THREE.Mesh(railGeo, railMat);
                rail.position.set(side * 2, 2.5, -7);
                group.add(rail);
            }

            // Wheels
            createTrainWheels(group, 2.5);

            return group;
        }

        function createTrainWheels(group, spacing) {
            const wheelMat = new THREE.MeshPhongMaterial({
                color: 0x222222,
                shininess: 80
            });

            for (let z = -1; z <= 1; z += 2) {
                for (let side = -1; side <= 1; side += 2) {
                    const wheelGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.5, 16);
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(side * 2.8, 1.2, z * spacing);
                    wheel.castShadow = true;
                    group.add(wheel);
                }
            }
        }

        function updateTrains(deltaTime) {
            for (const train of trains) {
                const data = train.userData;

                // Move along track
                data.progress += data.speed * data.direction * deltaTime;

                // Loop around
                if (data.progress > 1) {
                    data.progress = 0;
                } else if (data.progress < 0) {
                    data.progress = 1;
                }

                // Calculate position on track
                const x = data.startX + (data.endX - data.startX) * data.progress;
                const z = data.startZ + (data.endZ - data.startZ) * data.progress;
                const y = getTerrainHeight(x, z) + 1;

                train.position.set(x, y, z);
            }
        }

        function createTree() {
            const group = new THREE.Group();

            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 5, 6);
            const trunkMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            group.add(trunk);

            // Foliage
            const foliageGeo = new THREE.ConeGeometry(4, 8, 8);
            const foliageMat = new THREE.MeshPhongMaterial({ color: 0x2e7d32 });
            const foliage = new THREE.Mesh(foliageGeo, foliageMat);
            foliage.position.y = 8;
            foliage.castShadow = true;
            group.add(foliage);

            const scale = 0.5 + Math.random() * 1;
            group.scale.set(scale, scale, scale);

            return group;
        }

        // ==================== BALLOONS ====================
        const BALLOON_COLORS = [
            { color: 0xff4444, points: 10 },  // Red
            { color: 0xffff44, points: 15 },  // Yellow
            { color: 0x4488ff, points: 20 },  // Blue
            { color: 0x44ff44, points: 25 },  // Green
            { color: 0xff44ff, points: 30 },  // Purple
            { color: 0xff8844, points: 50 }   // Orange (rare)
        ];

        function createBalloon() {
            const group = new THREE.Group();

            // Select color
            const colorIndex = Math.random() < 0.1 ? 5 : Math.floor(Math.random() * 5);
            const { color, points } = BALLOON_COLORS[colorIndex];

            // Balloon body (BIG balloons!)
            const balloonGeo = new THREE.SphereGeometry(2.5, 16, 12);
            balloonGeo.scale(1, 1.3, 1);

            const balloonMat = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 100,
                specular: 0x444444,
                emissive: color,
                emissiveIntensity: 0.15
            });

            const balloon = new THREE.Mesh(balloonGeo, balloonMat);
            balloon.castShadow = true;
            group.add(balloon);

            // Knot
            const knotGeo = new THREE.ConeGeometry(0.3, 0.5, 6);
            const knot = new THREE.Mesh(knotGeo, balloonMat);
            knot.position.y = -3.3;
            knot.rotation.x = Math.PI;
            group.add(knot);

            // String
            const stringPoints = [];
            for (let i = 0; i < 12; i++) {
                stringPoints.push(new THREE.Vector3(
                    Math.sin(i * 0.4) * 0.15,
                    -3.5 - i * 0.6,
                    0
                ));
            }
            const stringGeo = new THREE.BufferGeometry().setFromPoints(stringPoints);
            const stringMat = new THREE.LineBasicMaterial({ color: 0x666666 });
            const string = new THREE.Line(stringGeo, stringMat);
            group.add(string);

            // Random position
            const angle = Math.random() * Math.PI * 2;
            const radius = 50 + Math.random() * CONFIG.BALLOON_SPAWN_RADIUS;
            group.position.set(
                Math.cos(angle) * radius,
                CONFIG.BALLOON_MIN_HEIGHT + Math.random() * (CONFIG.BALLOON_MAX_HEIGHT - CONFIG.BALLOON_MIN_HEIGHT),
                Math.sin(angle) * radius
            );

            // Random size (bigger balloons!)
            const scale = 1.5 + Math.random() * 1.0;
            group.scale.set(scale, scale, scale);

            group.userData = {
                color: color,
                points: points,
                radius: scale * 3.5,  // Bigger collision radius for bigger balloons
                floatPhase: Math.random() * Math.PI * 2,
                floatSpeed: CONFIG.BALLOON_FLOAT_SPEED * (0.8 + Math.random() * 0.4),
                originalY: group.position.y
            };

            scene.add(group);
            balloons.push(group);

            return group;
        }

        function updateBalloons(deltaTime) {
            for (const balloon of balloons) {
                balloon.userData.floatPhase += balloon.userData.floatSpeed * deltaTime;
                balloon.position.y = balloon.userData.originalY +
                    Math.sin(balloon.userData.floatPhase) * CONFIG.BALLOON_FLOAT_AMPLITUDE;
                balloon.rotation.y += deltaTime * 0.2;
            }
        }

        // ==================== AA CANNONS ====================
        function createAACannon(x, z) {
            const group = new THREE.Group();

            // Simple base
            const baseGeo = new THREE.CylinderGeometry(2, 2.5, 1.5, 8);
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 0.75;
            group.add(base);

            // Turret
            const turretGeo = new THREE.SphereGeometry(1.5, 8, 6);
            const turretMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const turret = new THREE.Mesh(turretGeo, turretMat);
            turret.position.y = 2;
            group.add(turret);

            // Barrel group (for rotation)
            const barrelGroup = new THREE.Group();
            barrelGroup.position.y = 2;

            // Dual barrels (simpler)
            const barrelMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
            for (let i = -1; i <= 1; i += 2) {
                const barrelGeo = new THREE.CylinderGeometry(0.15, 0.2, 4, 6);
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.x = Math.PI / 2;
                barrel.position.set(i * 0.5, 0, 2);
                barrelGroup.add(barrel);
            }

            // Single muzzle flash light
            const muzzleLight = new THREE.PointLight(0xff6600, 0, 15);
            muzzleLight.position.set(0, 0, 4.5);
            barrelGroup.add(muzzleLight);

            group.add(barrelGroup);

            // Position
            const groundY = getTerrainHeight(x, z);
            group.position.set(x, groundY, z);

            group.userData = {
                barrelGroup: barrelGroup,
                muzzleLight: muzzleLight,
                lastFired: 0,
                fireRate: CONFIG.AA_FIRE_RATE * (0.7 + Math.random() * 0.3),
                burstCount: 0,
                burstMax: 3 + Math.floor(Math.random() * 2)
            };

            scene.add(group);
            aaCannons.push(group);

            return group;
        }

        // Track player direction changes for AA prediction
        function updatePlayerDirectionTracking(deltaTime) {
            const currentVel = gameState.velocity.clone().normalize();
            const lastVel = gameState.lastVelocity;

            // Calculate how much direction changed
            const dot = currentVel.dot(lastVel);
            const changeThisFrame = Math.max(0, 1 - dot) * 10;  // 0 when straight, high when turning

            // Update history
            gameState.velocityHistory.push(changeThisFrame);
            if (gameState.velocityHistory.length > 30) {  // Track last ~0.5 seconds
                gameState.velocityHistory.shift();
            }

            // Calculate average direction change (0 = flying straight, higher = dodging)
            const sum = gameState.velocityHistory.reduce((a, b) => a + b, 0);
            gameState.directionChangeAmount = sum / Math.max(1, gameState.velocityHistory.length);

            gameState.lastVelocity.copy(currentVel);
        }

        function updateAACannons(deltaTime) {
            // Update direction tracking
            updatePlayerDirectionTracking(deltaTime);

            for (const cannon of aaCannons) {
                const distance = cannon.position.distanceTo(gameState.position);

                if (distance < CONFIG.AA_RANGE) {
                    // PREDICTIVE TARGETING: Calculate where player will be
                    const timeToTarget = distance / CONFIG.AA_BULLET_SPEED;
                    const predictionTime = Math.min(timeToTarget * CONFIG.AA_PREDICTION_TIME, 2);

                    // Predict future position based on current velocity
                    const predictedPos = gameState.position.clone().add(
                        gameState.velocity.clone().multiplyScalar(predictionTime)
                    );

                    // Direction to predicted position
                    const direction = new THREE.Vector3().subVectors(predictedPos, cannon.position).normalize();
                    const targetYaw = Math.atan2(direction.x, direction.z);
                    const targetPitch = Math.asin(Math.max(-0.99, Math.min(0.99, direction.y)));

                    // Smooth rotation toward predicted position
                    const barrelGroup = cannon.userData.barrelGroup;
                    const trackSpeed = CONFIG.AA_TRACKING_SPEED * deltaTime * 8;
                    barrelGroup.rotation.y += (targetYaw - barrelGroup.rotation.y) * trackSpeed;
                    barrelGroup.rotation.x += (-targetPitch - barrelGroup.rotation.x) * trackSpeed;

                    // Fire in bursts
                    if (gameState.gameTime - cannon.userData.lastFired > 0.15) {  // Burst fire rate
                        if (cannon.userData.burstCount < cannon.userData.burstMax) {
                            fireAACannon(cannon, predictedPos);
                            cannon.userData.burstCount++;
                            cannon.userData.lastFired = gameState.gameTime;
                        } else if (gameState.gameTime - cannon.userData.lastFired > cannon.userData.fireRate) {
                            // Reset burst after cooldown
                            cannon.userData.burstCount = 0;
                        }
                    }
                }
            }
        }

        function fireAACannon(cannon, targetPos) {
            const barrelGroup = cannon.userData.barrelGroup;

            // Calculate accuracy based on player's flight pattern
            // Flying straight = very accurate, dodging = less accurate
            const dodgeFactor = Math.min(1, gameState.directionChangeAmount / 2);
            const accuracy = CONFIG.AA_BASE_ACCURACY + (CONFIG.AA_DODGE_ACCURACY - CONFIG.AA_BASE_ACCURACY) * dodgeFactor;

            // Direction toward predicted position with accuracy spread
            const spawnPos = cannon.position.clone();
            spawnPos.y += 2.5;

            const direction = new THREE.Vector3().subVectors(targetPos, spawnPos).normalize();

            // Add spread based on accuracy (less spread when player flies straight)
            direction.x += (Math.random() - 0.5) * accuracy;
            direction.y += (Math.random() - 0.5) * accuracy;
            direction.z += (Math.random() - 0.5) * accuracy * 0.5;
            direction.normalize();

            // Move spawn point to barrel end
            spawnPos.add(direction.clone().multiplyScalar(6));

            createBullet(spawnPos, direction, 'enemy');
            createAATracer(spawnPos.clone(), direction.clone());

            // Muzzle flash
            cannon.userData.muzzleLight.intensity = 3;
            setTimeout(() => {
                cannon.userData.muzzleLight.intensity = 0;
            }, 50);

            audioManager.playAAFire();
        }

        // Bright tracer for AA fire (optimized - no point lights)
        function createAATracer(position, direction) {
            // Simple bright line tracer
            const points = [];
            for (let i = 0; i < 15; i++) {
                points.push(position.clone().add(direction.clone().multiplyScalar(-i * 1.2)));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 1
            });

            const line = new THREE.Line(geometry, material);

            line.userData = {
                direction: direction.clone().normalize(),
                speed: CONFIG.AA_BULLET_SPEED,
                lifetime: 2.0,
                age: 0
            };

            scene.add(line);
            tracers.push(line);

            return line;
        }

        // ==================== BULLETS ====================
        function createBullet(position, direction, owner) {
            const bulletGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({
                color: owner === 'player' ? 0x00ff00 : 0xff6600,
                transparent: true,
                opacity: 0.9
            });

            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            bullet.position.copy(position);

            bullet.userData = {
                direction: direction.clone().normalize(),
                speed: owner === 'player' ? CONFIG.BULLET_SPEED : CONFIG.AA_BULLET_SPEED,
                owner: owner,
                lifetime: CONFIG.BULLET_LIFETIME,
                age: 0
            };

            scene.add(bullet);
            bullets.push(bullet);

            return bullet;
        }

        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                const data = bullet.userData;

                // Move bullet
                bullet.position.add(data.direction.clone().multiplyScalar(data.speed * deltaTime));
                data.age += deltaTime;

                // Remove old bullets
                if (data.age > data.lifetime || bullet.position.y < 0) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }

        // ==================== TRACERS ====================
        function createTracer(position, direction, color) {
            const points = [];
            for (let i = 0; i < 15; i++) {
                points.push(position.clone().add(direction.clone().multiplyScalar(-i * 0.5)));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1
            });

            const line = new THREE.Line(geometry, material);

            line.userData = {
                direction: direction.clone().normalize(),
                speed: color === 0x00ff00 ? CONFIG.BULLET_SPEED : CONFIG.AA_BULLET_SPEED,
                lifetime: 0.8,
                age: 0
            };

            scene.add(line);
            tracers.push(line);

            return line;
        }

        function updateTracers(deltaTime) {
            for (let i = tracers.length - 1; i >= 0; i--) {
                const tracer = tracers[i];
                const data = tracer.userData;

                // Move tracer
                const movement = data.direction.clone().multiplyScalar(data.speed * deltaTime);
                const positions = tracer.geometry.attributes.position.array;
                for (let j = 0; j < positions.length; j += 3) {
                    positions[j] += movement.x;
                    positions[j + 1] += movement.y;
                    positions[j + 2] += movement.z;
                }
                tracer.geometry.attributes.position.needsUpdate = true;

                // Fade out
                data.age += deltaTime;
                tracer.material.opacity = 1 - (data.age / data.lifetime);

                // Remove when done
                if (data.age > data.lifetime) {
                    scene.remove(tracer);
                    tracers.splice(i, 1);
                }
            }
        }

        // ==================== PARTICLES ====================
        function createExplosion(position, color) {
            const particleCount = 40;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            const baseColor = new THREE.Color(color);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;

                const c = baseColor.clone().offsetHSL(Math.random() * 0.1 - 0.05, 0, Math.random() * 0.2);
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;

                sizes[i] = 0.3 + Math.random() * 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                sizeAttenuation: true
            });

            const particleSystem = new THREE.Points(geometry, material);

            // Velocities for each particle
            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 15,
                    (Math.random() - 0.5) * 20
                ));
            }

            particleSystem.userData = {
                velocities: velocities,
                lifetime: 1.5,
                age: 0
            };

            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const system = particles[i];
                const data = system.userData;
                const positions = system.geometry.attributes.position.array;

                for (let j = 0; j < data.velocities.length; j++) {
                    const vel = data.velocities[j];
                    vel.y -= 15 * deltaTime; // Gravity

                    positions[j * 3] += vel.x * deltaTime;
                    positions[j * 3 + 1] += vel.y * deltaTime;
                    positions[j * 3 + 2] += vel.z * deltaTime;
                }

                system.geometry.attributes.position.needsUpdate = true;

                data.age += deltaTime;
                system.material.opacity = 1 - (data.age / data.lifetime);

                if (data.age > data.lifetime) {
                    scene.remove(system);
                    particles.splice(i, 1);
                }
            }
        }

        // ==================== PLAYER SHOOTING ====================
        function playerShoot() {
            if (gameState.gameTime - gameState.lastFireTime < CONFIG.FIRE_RATE) return;

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);

            const spawnPos = gameState.position.clone().add(direction.clone().multiplyScalar(3));

            createBullet(spawnPos, direction, 'player');
            createTracer(spawnPos.clone(), direction.clone(), 0x00ff00);

            audioManager.playShoot();
            gameState.lastFireTime = gameState.gameTime;
        }

        // ==================== COLLISION DETECTION ====================
        function checkCollisions() {
            // Player bullets vs balloons
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (bullet.userData.owner !== 'player') continue;

                for (let j = balloons.length - 1; j >= 0; j--) {
                    const balloon = balloons[j];
                    const distance = bullet.position.distanceTo(balloon.position);

                    if (distance < balloon.userData.radius + 0.5) {
                        // Hit balloon!
                        gameState.score += balloon.userData.points;
                        createExplosion(balloon.position.clone(), balloon.userData.color);
                        audioManager.playPop(0.8 + Math.random() * 0.4);

                        scene.remove(balloon);
                        balloons.splice(j, 1);
                        scene.remove(bullet);
                        bullets.splice(i, 1);

                        showMessage(`+${balloon.userData.points}!`);
                        break;
                    }
                }
            }

            // Enemy bullets vs player
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (bullet.userData.owner !== 'enemy') continue;

                const distance = bullet.position.distanceTo(gameState.position);
                if (distance < 5) {
                    takeDamage(CONFIG.AA_DAMAGE);
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }

        // ==================== DAMAGE ====================
        function takeDamage(amount) {
            gameState.health -= amount;
            audioManager.playHit();

            // Show damage overlay
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = '0.6';
            setTimeout(() => { overlay.style.opacity = '0'; }, 200);

            // Screen shake
            const shakeAmount = 0.1;
            camera.rotation.x += (Math.random() - 0.5) * shakeAmount;
            camera.rotation.y += (Math.random() - 0.5) * shakeAmount;

            if (gameState.health <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameState.isRunning = false;
            audioManager.playExplosion();

            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('game-over').style.display = 'flex';
            document.exitPointerLock();
        }

        // ==================== HUD ====================
        function updateHUD() {
            document.getElementById('score-value').textContent = gameState.score;
            document.getElementById('health-fill').style.width = `${(gameState.health / CONFIG.PLAYER_MAX_HEALTH) * 100}%`;
            document.getElementById('altitude-value').textContent = Math.round(gameState.position.y) + 'm';
            document.getElementById('speed-value').textContent = Math.round(gameState.speed) + 'km/h';
            document.getElementById('balloon-count').textContent = balloons.length;
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.opacity = '1';
            setTimeout(() => { msg.style.opacity = '0'; }, 800);
        }

        // ==================== PLAYER MOVEMENT ====================
        function updatePlayer(deltaTime) {
            // Pitch control
            if (keys.w || keys.ArrowUp) {
                gameState.pitch -= CONFIG.PITCH_SPEED * deltaTime;
            }
            if (keys.s || keys.ArrowDown) {
                gameState.pitch += CONFIG.PITCH_SPEED * deltaTime;
            }
            gameState.pitch = THREE.MathUtils.clamp(gameState.pitch, -Math.PI / 3, Math.PI / 3);
            gameState.pitch *= 0.98; // Damping

            // Roll control
            if (keys.a || keys.ArrowLeft) {
                gameState.roll += CONFIG.ROLL_SPEED * deltaTime;
            }
            if (keys.d || keys.ArrowRight) {
                gameState.roll -= CONFIG.ROLL_SPEED * deltaTime;
            }
            gameState.roll = THREE.MathUtils.clamp(gameState.roll, -Math.PI / 2, Math.PI / 2);
            gameState.roll *= 0.96; // Damping

            // Yaw from roll (realistic banking)
            gameState.yaw += gameState.roll * CONFIG.YAW_FROM_ROLL * deltaTime;

            // Apply rotations
            gameState.rotation.set(gameState.pitch, gameState.yaw, gameState.roll, 'YXZ');

            // Speed control (automatic - pitch affects speed)
            const pitchFactor = Math.sin(gameState.pitch);
            gameState.speed += pitchFactor * 30 * deltaTime;
            gameState.speed = THREE.MathUtils.clamp(gameState.speed, CONFIG.PLANE_MIN_SPEED, CONFIG.PLANE_MAX_SPEED);

            // Calculate velocity from rotation
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyEuler(gameState.rotation);
            gameState.velocity.copy(forward.multiplyScalar(gameState.speed));

            // Update position
            gameState.position.add(gameState.velocity.clone().multiplyScalar(deltaTime));

            // Ground collision
            if (gameState.position.y < 15) {
                gameState.position.y = 15;
                if (gameState.pitch > 0) gameState.pitch *= 0.5;
            }

            // Keep in bounds
            if (gameState.position.length() > CONFIG.WORLD_SIZE) {
                const dir = gameState.position.clone().normalize();
                gameState.position.copy(dir.multiplyScalar(CONFIG.WORLD_SIZE));
                gameState.yaw += Math.PI * deltaTime;
            }

            // Update camera
            camera.position.copy(gameState.position);
            camera.rotation.copy(gameState.rotation);

            // Apply mouse look
            camera.rotation.y += gameState.lookX;
            camera.rotation.x += gameState.lookY;

            // Update engine sound
            audioManager.updateEngine(gameState.speed);
        }

        // ==================== INPUT HANDLERS ====================
        function setupInput() {
            document.addEventListener('keydown', (e) => {
                if (e.code in keys) keys[e.code] = true;
                if (e.code === 'KeyW') keys.w = true;
                if (e.code === 'KeyS') keys.s = true;
                if (e.code === 'KeyA') keys.a = true;
                if (e.code === 'KeyD') keys.d = true;

                if (e.code === 'Escape' && gameState.isRunning) {
                    gameState.isPaused = !gameState.isPaused;
                    if (gameState.isPaused) {
                        document.exitPointerLock();
                    } else {
                        canvas.requestPointerLock();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code in keys) keys[e.code] = false;
                if (e.code === 'KeyW') keys.w = false;
                if (e.code === 'KeyS') keys.s = false;
                if (e.code === 'KeyA') keys.a = false;
                if (e.code === 'KeyD') keys.d = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas) {
                    gameState.lookX -= e.movementX * CONFIG.LOOK_SENSITIVITY;
                    gameState.lookY -= e.movementY * CONFIG.LOOK_SENSITIVITY;
                    gameState.lookX = THREE.MathUtils.clamp(gameState.lookX, -CONFIG.LOOK_MAX_X, CONFIG.LOOK_MAX_X);
                    gameState.lookY = THREE.MathUtils.clamp(gameState.lookY, -CONFIG.LOOK_MAX_Y, CONFIG.LOOK_MAX_Y);
                }
            });

            document.addEventListener('mousedown', (e) => {
                if (e.button === 0) mouseDown = true;
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) mouseDown = false;
            });

            // Start screen click
            document.getElementById('start-screen').addEventListener('click', startGame);

            // Game over click
            document.getElementById('game-over').addEventListener('click', () => {
                document.getElementById('game-over').style.display = 'none';
                resetGame();
                startGame();
            });

            // Pointer lock change
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement !== canvas && gameState.isRunning && !gameState.isPaused) {
                    gameState.isPaused = true;
                }
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ==================== GAME CONTROL ====================
        async function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            await audioManager.init();
            canvas.requestPointerLock();
            gameState.isRunning = true;
            gameState.isPaused = false;
        }

        function resetGame() {
            // Reset player
            gameState.score = 0;
            gameState.health = CONFIG.PLAYER_MAX_HEALTH;
            gameState.position.set(0, 100, 0);
            gameState.velocity.set(0, 0, -CONFIG.PLANE_MIN_SPEED);
            gameState.rotation.set(0, 0, 0);
            gameState.speed = CONFIG.PLANE_MIN_SPEED + 20;
            gameState.pitch = 0;
            gameState.roll = 0;
            gameState.yaw = 0;
            gameState.lookX = 0;
            gameState.lookY = 0;
            gameState.gameTime = 0;

            // Clear entities
            while (balloons.length > 0) {
                scene.remove(balloons.pop());
            }
            while (bullets.length > 0) {
                scene.remove(bullets.pop());
            }
            while (particles.length > 0) {
                scene.remove(particles.pop());
            }
            while (tracers.length > 0) {
                scene.remove(tracers.pop());
            }

            // Respawn balloons
            for (let i = 0; i < CONFIG.BALLOON_COUNT; i++) {
                createBalloon();
            }
        }

        // ==================== GAME LOOP ====================
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(clock.getDelta(), 0.1);

            if (gameState.isRunning && !gameState.isPaused) {
                gameState.gameTime += deltaTime;

                // Update player
                updatePlayer(deltaTime);

                // Shooting
                if (mouseDown || keys.Space) {
                    playerShoot();
                }

                // Update entities
                updateBalloons(deltaTime);
                updateBullets(deltaTime);
                updateTracers(deltaTime);
                updateAACannons(deltaTime);
                updateParticles(deltaTime);
                updateTrains(deltaTime);

                // Collisions
                checkCollisions();

                // Spawn new balloons
                if (balloons.length < 15) {
                    createBalloon();
                }

                // HUD
                updateHUD();
            }

            renderer.render(scene, camera);
        }

        // ==================== INITIALIZATION ====================
        function init() {
            setupLighting();
            createSky();
            createClouds();
            createTerrain();

            // Spawn balloons
            for (let i = 0; i < CONFIG.BALLOON_COUNT; i++) {
                createBalloon();
            }

            // Spawn AA cannons - spread across the map
            const cannonPositions = [
                [-150, -150], [150, -150], [0, 200],
                [-200, 100], [200, 100], [0, -200],
                [-300, 0], [300, 0], [0, 300],
                [-100, 250], [100, -280], [-250, -200],
                [280, 220], [-180, 300]
            ];
            for (let i = 0; i < Math.min(CONFIG.AA_CANNON_COUNT, cannonPositions.length); i++) {
                const [x, z] = cannonPositions[i];
                createAACannon(x, z);
            }

            // Setup fog
            scene.fog = new THREE.Fog(0x88bbff, 100, 600);

            setupInput();
            animate();
        }

        init();
    </script>
</body>
</html>
